:mod:`arkouda`
==============

.. py:module:: arkouda


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   categorical/index.rst
   client/index.rst
   dtypes/index.rst
   groupbyclass/index.rst
   join/index.rst
   numeric/index.rst
   pdarrayIO/index.rst
   pdarrayclass/index.rst
   pdarraycreation/index.rst
   pdarraysetops/index.rst
   registration/index.rst
   sorting/index.rst
   strings/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   arkouda.pdarray
   arkouda.GroupBy
   arkouda.Strings
   arkouda.Categorical



Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.set_defaults
   arkouda.connect
   arkouda.disconnect
   arkouda.shutdown
   arkouda.get_config
   arkouda.get_mem_used
   arkouda.check_np_dtype
   arkouda.translate_np_dtype
   arkouda.resolve_scalar_dtype
   arkouda.info
   arkouda.any
   arkouda.all
   arkouda.is_sorted
   arkouda.sum
   arkouda.prod
   arkouda.min
   arkouda.max
   arkouda.argmin
   arkouda.argmax
   arkouda.mean
   arkouda.var
   arkouda.std
   arkouda.argsort
   arkouda.coargsort
   arkouda.local_argsort
   arkouda.sort
   arkouda.unique
   arkouda.in1d
   arkouda.concatenate
   arkouda.union1d
   arkouda.intersect1d
   arkouda.setdiff1d
   arkouda.setxor1d
   arkouda.array
   arkouda.zeros
   arkouda.ones
   arkouda.zeros_like
   arkouda.ones_like
   arkouda.arange
   arkouda.linspace
   arkouda.randint
   arkouda.uniform
   arkouda.standard_normal
   arkouda.random_strings_uniform
   arkouda.random_strings_lognormal
   arkouda.abs
   arkouda.log
   arkouda.exp
   arkouda.cumsum
   arkouda.cumprod
   arkouda.sin
   arkouda.cos
   arkouda.where
   arkouda.histogram
   arkouda.value_counts
   arkouda.ls_hdf
   arkouda.read_hdf
   arkouda.read_all
   arkouda.load
   arkouda.get_datasets
   arkouda.load_all
   arkouda.save_all
   arkouda.join_on_eq_with_dt
   arkouda.register_pda
   arkouda.attach_pda
   arkouda.unregister_pda


.. data:: verbose
   

   

.. data:: pdarrayIterThresh
   

   

.. data:: maxTransferBytes
   

   

.. data:: AllSymbols
   :annotation: = __AllSymbols__

   

.. function:: set_defaults()


.. function:: connect(server='localhost', port=5555, timeout=0)

   Connect to a running arkouda server.

   :param server: The hostname of the server (must be visible to the current
                  machine). Defaults to `localhost`.
   :type server: str, optional
   :param port: The port of the server. Defaults to 5555.
   :type port: int, optional
   :param timeout: The timeout in seconds for client send and receive operations.
                   Defaults to 0 seconds, whicn is interpreted as no timeout
   :type timeout: int, optional

   :returns:
   :rtype: None

   .. rubric:: Notes

   On success, prints the connected address, as seen by the server. If called
   with an existing connection, the socket will be re-initialized.


.. function:: disconnect()

   Disconnect from the arkouda server.


.. function:: shutdown()

   Tell the arkouda server to delete all objects and shut itself down.


.. function:: get_config()

   Get runtime information about the server.

   :returns: serverHostname
             serverPort
             numLocales
             numPUs (number of processor units per locale)
             maxTaskPar (maximum number of tasks per locale)
             physicalMemory
   :rtype: dict


.. function:: get_mem_used()

   Compute the amount of memory used by objects in the server's symbol table.

   :returns: Amount of memory allocated to symbol table objects.
   :rtype: int


.. data:: __version__
   

   

.. data:: DTypes
   

   

.. data:: dtype
   

   

.. data:: bool
   

   

.. data:: int64
   

   

.. data:: float64
   

   

.. data:: uint8
   

   

.. data:: str_
   

   

.. function:: check_np_dtype(dt)

   Assert that numpy dtype dt is one of the dtypes supported by arkouda,
   otherwise raise TypeError.


.. function:: translate_np_dtype(dt)

   Split numpy dtype dt into its kind and byte size, raising TypeError
   for unsupported dtypes.


.. function:: resolve_scalar_dtype(val)

   Try to infer what dtype arkouda_server should treat val as.


.. py:class:: pdarray(name, mydtype, size, ndim, shape, itemsize)

   The basic arkouda array class. This class contains only the
   attributies of the array; the data resides on the arkouda
   server. When a server operation results in a new array, arkouda
   will create a pdarray instance that points to the array data on
   the server. As such, the user should not initialize pdarray
   instances directly.

   .. attribute:: name

      The server-side identifier for the array

      :type: str

   .. attribute:: dtype

      The element type of the array

      :type: dtype

   .. attribute:: size

      The number of elements in the array

      :type: int

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: int

   .. attribute:: shape

      The sizes of each dimension of the array

      :type: tuple

   .. attribute:: itemsize

      The size in bytes of each element

      :type: int

   .. attribute:: BinOps
      

      

   .. attribute:: OpEqOps
      

      

   .. attribute:: objtype
      :annotation: = pdarray

      

   .. attribute:: __array_priority__
      :annotation: = 1000

      

   .. method:: __del__(self)



   .. method:: __bool__(self)



   .. method:: __len__(self)



   .. method:: __str__(self)


      Return str(self).


   .. method:: __repr__(self)


      Return repr(self).


   .. method:: format_other(self, other)


      Attempt to cast scalar other to the element dtype of this pdarray,
      and print the resulting value to a string (e.g. for sending to a
      server command). The user should not call this function directly.


   .. method:: binop(self, other, op)



   .. method:: r_binop(self, other, op)



   .. method:: __add__(self, other)



   .. method:: __radd__(self, other)



   .. method:: __sub__(self, other)



   .. method:: __rsub__(self, other)



   .. method:: __mul__(self, other)



   .. method:: __rmul__(self, other)



   .. method:: __truediv__(self, other)



   .. method:: __rtruediv__(self, other)



   .. method:: __floordiv__(self, other)



   .. method:: __rfloordiv__(self, other)



   .. method:: __mod__(self, other)



   .. method:: __rmod__(self, other)



   .. method:: __lshift__(self, other)



   .. method:: __rlshift__(self, other)



   .. method:: __rshift__(self, other)



   .. method:: __rrshift__(self, other)



   .. method:: __and__(self, other)



   .. method:: __rand__(self, other)



   .. method:: __or__(self, other)



   .. method:: __ror__(self, other)



   .. method:: __xor__(self, other)



   .. method:: __rxor__(self, other)



   .. method:: __pow__(self, other)



   .. method:: __rpow__(self, other)



   .. method:: __lt__(self, other)


      Return self<value.


   .. method:: __gt__(self, other)


      Return self>value.


   .. method:: __le__(self, other)


      Return self<=value.


   .. method:: __ge__(self, other)


      Return self>=value.


   .. method:: __eq__(self, other)


      Return self==value.


   .. method:: __ne__(self, other)


      Return self!=value.


   .. method:: __neg__(self)



   .. method:: __invert__(self)



   .. method:: opeq(self, other, op)



   .. method:: __iadd__(self, other)



   .. method:: __isub__(self, other)



   .. method:: __imul__(self, other)



   .. method:: __itruediv__(self, other)



   .. method:: __ifloordiv__(self, other)



   .. method:: __ilshift__(self, other)



   .. method:: __irshift__(self, other)



   .. method:: __iand__(self, other)



   .. method:: __ior__(self, other)



   .. method:: __ixor__(self, other)



   .. method:: __ipow__(self, other)



   .. method:: __getitem__(self, key)



   .. method:: __setitem__(self, key, value)



   .. method:: fill(self, value)


      Fill the array (in place) with a constant value.


   .. method:: any(self)


      Return True iff any element of the array evaluates to True.


   .. method:: all(self)


      Return True iff all elements of the array evaluate to True.


   .. method:: is_sorted(self)


      Return True iff the array is monotonically non-decreasing.


   .. method:: sum(self)


      Return the sum of all elements in the array.


   .. method:: prod(self)


      Return the product of all elements in the array. Return value is
      always a float.


   .. method:: min(self)


      Return the minimum value of the array.


   .. method:: max(self)


      Return the maximum value of the array.


   .. method:: argmin(self)


      Return the index of the first minimum value of the array.


   .. method:: argmax(self)


      Return the index of the first maximum value of the array.


   .. method:: mean(self)


      Return the mean of the array.


   .. method:: var(self, ddof=0)


      Compute the variance. See ``arkouda.var`` for details.


   .. method:: std(self, ddof=0)


      Compute the standard deviation. See ``arkouda.std`` for details.


   .. method:: to_ndarray(self)


      Convert the array to a np.ndarray, transferring array data from the
      arkouda server to Python. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A numpy ndarray with the same attributes and data as the pdarray
      :rtype: np.ndarray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``arkouda.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :meth:`array`

      .. rubric:: Examples

      >>> a = ak.arange(0, 5, 1)
      >>> a.to_ndarray()
      array([0, 1, 2, 3, 4])

      >>> type(a.to_ndarray())
      numpy.ndarray


   .. method:: to_cuda(self)


      Convert the array to a Numba DeviceND array, transferring array data from the
      arkouda server to Python via ndarray. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A Numba ndarray with the same attributes and data as the pdarray; on GPU
      :rtype: numba.DeviceNDArray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``arkouda.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :meth:`array`

      .. rubric:: Examples

      >>> a = ak.arange(0, 5, 1)
      >>> a.to_cuda()
      array([0, 1, 2, 3, 4])

      >>> type(a.to_cuda())
      numpy.devicendarray


   .. method:: save(self, prefix_path, dataset='array', mode='truncate')


      Save the pdarray to HDF5. The result is a collection of HDF5 files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in HDF5 files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: {'truncate' | 'append'}

      .. seealso:: :meth:`save_all`, :meth:`load`, :meth:`read_hdf`, :meth:`read_all`

      .. rubric:: Notes

      The prefix_path must be visible to the arkouda server and the user must have
      write permission.

      Output files have names of the form ``<prefix_path>_LOCALE<i>.hdf``, where ``<i>``
      ranges from 0 to ``numLocales``. If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.

      .. rubric:: Examples

      >>> a = ak.arange(0, 100, 1)
      >>> a.save('arkouda_range', dataset='array')

      Array is saved in numLocales files with names like ``tmp/arkouda_range_LOCALE0.hdf``

      The array can be read back in as follows

      >>> b = ak.load('arkouda_range', dataset='array')
      >>> (a == b).all()
      True



.. function:: info(pda)


.. function:: any(pda)

   Return True iff any element of the array evaluates to True.


.. function:: all(pda)

   Return True iff all elements of the array evaluate to True.


.. function:: is_sorted(pda)

   Return True iff the array is monotonically non-decreasing.


.. function:: sum(pda)

   Return the sum of all elements in the array.


.. function:: prod(pda)

   Return the product of all elements in the array. Return value is
   always a float.


.. function:: min(pda)

   Return the minimum value of the array.


.. function:: max(pda)

   Return the maximum value of the array.


.. function:: argmin(pda)

   Return the index of the first minimum value of the array.


.. function:: argmax(pda)

   Return the index of the first maximum value of the array.


.. function:: mean(pda)

   Return the mean of the array.


.. function:: var(pda, ddof=0)

   Return the variance of values in the array.

   :param pda: Values for which to find the variance
   :type pda: pdarray
   :param ddof: "Delta Degrees of Freedom" used in calculating mean
   :type ddof: int

   :returns: The scalar variance of the array
   :rtype: float

   .. seealso:: :func:`mean`, :func:`std`

   .. rubric:: Notes

   The variance is the average of the squared deviations from the mean,
   i.e.,  ``var = mean((x - x.mean())**2)``.

   The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
   If, however, `ddof` is specified, the divisor ``N - ddof`` is used
   instead.  In standard statistical practice, ``ddof=1`` provides an
   unbiased estimator of the variance of a hypothetical infinite population.
   ``ddof=0`` provides a maximum likelihood estimate of the variance for
   normally distributed variables.


.. function:: std(pda, ddof=0)

   Return the standard deviation of values in the array. The standard
   deviation is implemented as the square root of the variance.

   :param pda: values for which to find the variance
   :type pda: pdarray
   :param ddof: "Delta Degrees of Freedom" used in calculating mean
   :type ddof: int

   :returns: The scalar standard deviation of the array
   :rtype: float

   .. seealso:: :func:`mean`, :func:`var`

   .. rubric:: Notes

   The standard deviation is the square root of the average of the squared
   deviations from the mean, i.e., ``std = sqrt(mean((x - x.mean())**2))``.

   The average squared deviation is normally calculated as
   ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
   the divisor ``N - ddof`` is used instead. In standard statistical
   practice, ``ddof=1`` provides an unbiased estimator of the variance
   of the infinite population. ``ddof=0`` provides a maximum likelihood
   estimate of the variance for normally distributed variables. The
   standard deviation computed in this function is the square root of
   the estimated variance, so even with ``ddof=1``, it will not be an
   unbiased estimate of the standard deviation per se.


.. function:: argsort(pda)

   Return the permutation that sorts the array.

   :param pda: The array to sort (int64 or float64)
   :type pda: pdarray or Strings

   :returns: The indices such that ``pda[indices]`` is sorted
   :rtype: pdarray, int64

   .. seealso:: :func:`coargsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive.

   .. rubric:: Examples

   >>> a = ak.randint(0, 10, 10)
   >>> perm = ak.argsort(a)
   >>> a[perm]
   array([0, 1, 1, 3, 4, 5, 7, 8, 8, 9])


.. function:: coargsort(arrays)

   Return the permutation that groups the rows (left-to-right), if the
   input arrays are treated as columns. The permutation sorts numeric
   columns, but not strings -- strings are grouped, but not ordered.

   :param arrays: The columns (int64, float64, or Strings) to sort by row
   :type arrays: iterable of pdarray or Strings

   :returns: The indices that permute the rows to grouped order
   :rtype: pdarray, int64

   .. seealso:: :func:`argsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive. Starts with the
   last array and moves forward. This sort operates directly on numeric types,
   but for Strings, it operates on a hash. Thus, while grouping of equivalent
   strings is guaranteed, lexicographic ordering of the groups is not.

   .. rubric:: Examples

   >>> a = ak.array([0, 1, 0, 1])
   >>> b = ak.array([1, 1, 0, 0])
   >>> perm = ak.coargsort([a, b])
   >>> perm
   array([2, 0, 3, 1])
   >>> a[perm]
   array([0, 0, 1, 1])
   >>> b[perm]
   array([0, 1, 0, 1])


.. function:: local_argsort(pda)


.. function:: sort(pda)

   Return a sorted copy of the array. Only sorts numeric arrays; for Strings, use argsort.

   :param pda: The array to sort (int64 or float64)
   :type pda: pdarray or Categorical

   :returns: The sorted copy of pda
   :rtype: pdarray, int64 or float64

   .. seealso:: :func:`argsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive.

   .. rubric:: Examples

   >>> a = ak.randint(0, 10, 10)
   >>> sorted = ak.sort(a)
   >>> a
   array([0, 1, 1, 3, 4, 5, 7, 8, 8, 9])


.. function:: unique(pda, return_counts=False)

   Find the unique elements of an array.

   Returns the unique elements of an array, sorted if the values are integers.
   There is an optional output in addition to the unique elements: the number
   of times each unique value comes up in the input array.

   :param pda: Input array.
   :type pda: pdarray or Strings or Categorical
   :param return_counts: If True, also return the number of times each unique item appears
                         in `pda`.
   :type return_counts: bool, optional

   :returns: * **unique** (*pdarray or Strings*) -- The unique values. If input dtype is int64, return values will be sorted.
             * **unique_counts** (*pdarray, optional*) -- The number of times each of the unique values comes up in the
               original array. Only provided if `return_counts` is True.

   .. rubric:: Notes

   For integer arrays, this function checks to see whether `pda` is sorted and, if so,
   whether it is already unique. This step can save considerable computation.
   Otherwise, this function will sort `pda`. For

   .. rubric:: Examples

   >>> A = ak.array([3, 2, 1, 1, 2, 3])
   >>> ak.unique(A)
   array([1, 2, 3])


.. function:: in1d(pda1, pda2, invert=False)

   Test whether each element of a 1-D array is also present in a second array.

   Returns a boolean array the same length as `pda1` that is True
   where an element of `pda1` is in `pda2` and False otherwise.

   :param pda1: Input array.
   :type pda1: pdarray or Strings or Categorical
   :param pda2: The values against which to test each value of `pda1`. Must be the
                same type as `pda1`.
   :type pda2: pdarray or Strings
   :param invert: If True, the values in the returned array are inverted (that is,
                  False where an element of `pda1` is in `pda2` and True otherwise).
                  Default is False. ``ak.in1d(a, b, invert=True)`` is equivalent
                  to (but is faster than) ``~ak.in1d(a, b)``.
   :type invert: bool, optional

   :returns: The values `pda1[in1d]` are in `pda2`.
   :rtype: pdarray, bool

   .. seealso:: :func:`unique`, :func:`intersect1d`, :func:`union1d`

   .. rubric:: Notes

   `in1d` can be considered as an element-wise function version of the
   python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is logically
   equivalent to ``ak.array([item in b for item in a])``, but is much
   faster and scales to arbitrarily large ``a``.


.. function:: concatenate(arrays)

   Concatenate an iterable of ``pdarray`` objects into one ``pdarray``.

   :param arrays: The arrays to concatenate. Must all have same dtype.
   :type arrays: iterable of ``pdarray`` or Strings or Categorical

   :returns: Single array containing all values, in original order
   :rtype: pdarray

   .. rubric:: Examples

   >>> ak.concatenate([ak.array([1, 2, 3]), ak.array([4, 5, 6])])
   array([1, 2, 3, 4, 5, 6])


.. function:: union1d(pda1, pda2)

   Find the union of two arrays.

   Return the unique, sorted array of values that are in either of the two
   input arrays.

   :param pda1: Input array
   :type pda1: pdarray
   :param pda2: Input array
   :type pda2: pdarray

   :returns: Unique, sorted union of the input arrays.
   :rtype: pdarray

   .. seealso:: :func:`intersect1d`, :func:`unique`

   .. rubric:: Examples

   >>> ak.union1d([-1, 0, 1], [-2, 0, 2])
   array([-2, -1,  0,  1,  2])


.. function:: intersect1d(pda1, pda2, assume_unique=False)

   Find the intersection of two arrays.

   Return the sorted, unique values that are in both of the input arrays.

   :param pda1: Input array
   :type pda1: pdarray
   :param pda2: Input array
   :type pda2: pdarray
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array of common and unique elements.
   :rtype: pdarray

   .. seealso:: :func:`unique`, :func:`union1d`

   .. rubric:: Examples

   >>> ak.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
   array([1, 3])


.. function:: setdiff1d(pda1, pda2, assume_unique=False)

   Find the set difference of two arrays.

   Return the sorted, unique values in `pda1` that are not in `pda2`.

   :param pda1: Input array.
   :type pda1: pdarray
   :param pda2: Input comparison array.
   :type pda2: pdarray
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array of values in `pda1` that are not in `pda2`.
   :rtype: pdarray

   .. seealso:: :func:`unique`, :func:`setxor1d`

   .. rubric:: Examples

   >>> a = ak.array([1, 2, 3, 2, 4, 1])
   >>> b = ak.array([3, 4, 5, 6])
   >>> ak.setdiff1d(a, b)
   array([1, 2])


.. function:: setxor1d(pda1, pda2, assume_unique=False)

   Find the set exclusive-or (symmetric difference) of two arrays.

   Return the sorted, unique values that are in only one (not both) of the
   input arrays.

   :param pda1: Input array.
   :type pda1: pdarray
   :param pda2: Input array.
   :type pda2: pdarray
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array of unique values that are in only one of the input
             arrays.
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([1, 2, 3, 2, 4])
   >>> b = ak.array([2, 3, 5, 7, 5])
   >>> ak.setxor1d(a,b)
   array([1, 4, 5, 7])


.. function:: array(a)

   Convert an iterable to a pdarray, sending data to the arkouda server.

   :param a: Rank-1 array of a supported dtype
   :type a: array_like

   :returns: Instance of pdarray stored on arkouda server
   :rtype: pdarray

   .. seealso:: :func:`pdarray.to_ndarray`

   .. rubric:: Notes

   The number of bytes in the input array cannot exceed `arkouda.maxTransferBytes`,
   otherwise a RuntimeError will be raised. This is to protect the user
   from overwhelming the connection between the Python client and the arkouda
   server, under the assumption that it is a low-bandwidth connection. The user
   may override this limit by setting ak.maxTransferBytes to a larger value,
   but should proceed with caution.

   .. rubric:: Examples

   >>> a = [3, 5, 7]
   >>> b = ak.array(a)
   >>> b
   array([3, 5, 7])

   >>> type(b)
   arkouda.pdarray


.. function:: zeros(size, dtype=np.float64)

   Create a pdarray filled with zeros.

   :param size: Size of the array (only rank-1 arrays supported)
   :type size: int
   :param dtype: Type of resulting array, default float64
   :type dtype: {float64, int64, bool}

   :returns: Zeros of the requested size and dtype
   :rtype: pdarray

   .. seealso:: :func:`ones`, :func:`zeros_like`

   .. rubric:: Examples

   >>> ak.zeros(5, dtype=ak.int64)
   array([0, 0, 0, 0, 0])
   >>> ak.zeros(5, dtype=ak.float64)
   array([0, 0, 0, 0, 0])
   >>> ak.zeros(5, dtype=ak.bool)
   array([False, False, False, False, False])


.. function:: ones(size, dtype=float64)

   Create a pdarray filled with ones.

   :param size: Size of the array (only rank-1 arrays supported)
   :type size: int
   :param dtype: Resulting array type, default float64
   :type dtype: {float64, int64, bool}

   :returns: Ones of the requested size and dtype
   :rtype: pdarray

   .. seealso:: :func:`zeros`, :func:`ones_like`

   .. rubric:: Examples

   >>> ak.ones(5, dtype=ak.int64)
   array([1, 1, 1, 1, 1])
   >>> ak.ones(5, dtype=ak.float64)
   array([1, 1, 1, 1, 1])
   >>> ak.ones(5, dtype=ak.bool)
   array([True, True, True, True, True])


.. function:: zeros_like(pda)

   Create a zero-filled pdarray of the same size and dtype as an existing pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.zeros(pda.size, pda.dtype)
   :rtype: pdarray

   .. seealso:: :func:`zeros`, :func:`ones_like`


.. function:: ones_like(pda)

   Create a one-filled pdarray of the same size and dtype as an existing pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.ones(pda.size, pda.dtype)
   :rtype: pdarray

   .. seealso:: :func:`ones`, :func:`zeros_like`


.. function:: arange(*args)

   arange([start,] stop[, stride])

   Create a pdarray of consecutive integers within the interval [start, stop).
   If only one arg is given then arg is the stop parameter. If two args are given
   then the first arg is start and second is stop. If three args are given
   then the first arg is start, second is stop, third is stride.

   :param start: Starting value (inclusive), the default starting value is 0
   :type start: int, optional
   :param stop: Stopping value (exclusive)
   :type stop: int
   :param stride: The difference between consecutive elements, the default stride is 1,
                  if stride is specified then start must also be specified
   :type stride: int, optional

   :returns: Integers from start (inclusive) to stop (exclusive) by stride
   :rtype: pdarray, int64

   .. seealso:: :func:`linspace`, :func:`zeros`, :func:`ones`, :func:`randint`

   .. rubric:: Notes

   Negative strides result in decreasing values. Currently, only int64 pdarrays
   can be created with this function. For float64 arrays, use linspace.

   .. rubric:: Examples

   >>> ak.arange(0, 5, 1)
   array([0, 1, 2, 3, 4])

   >>> ak.arange(5, 0, -1)
   array([5, 4, 3, 2, 1])

   >>> ak.arange(0, 10, 2)
   array([0, 2, 4, 6, 8])


.. function:: linspace(start, stop, length)

   Create a pdarray of linearly spaced points in a closed interval.

   :param start: Start of interval (inclusive)
   :type start: scalar
   :param stop: End of interval (inclusive)
   :type stop: scalar
   :param length: Number of points
   :type length: int

   :returns: Array of evenly spaced points along the interval
   :rtype: pdarray, float64

   .. seealso:: :func:`arange`

   .. rubric:: Examples

   >>> ak.linspace(0, 1, 5)
   array([0, 0.25, 0.5, 0.75, 1])


.. function:: randint(low, high, size, dtype=int64)

   Generate a pdarray with random values in a specified range.

   :param low: The low value (inclusive) of the range
   :type low: int
   :param high: The high value (exclusive for int, inclusive for float) of the range
   :type high: int
   :param size: The length of the returned array
   :type size: int
   :param dtype: The dtype of the array
   :type dtype: {int64, float64, bool}

   :returns: Values drawn uniformly from the specified range having the desired dtype
   :rtype: pdarray

   .. rubric:: Notes

   Calling randint with dtype=float64 will result in uniform non-integral
   floating point values.

   .. rubric:: Examples

   >>> ak.randint(0, 10, 5)
   array([5, 7, 4, 8, 3])

   >>> ak.randint(0, 1, 3, dtype=ak.float64)
   array([0.92176432277231968, 0.083130710959903542, 0.68894208386667544])

   >>> ak.randint(0, 1, 5, dtype=ak.bool)
   array([True, False, True, True, True])


.. function:: uniform(size, low=0.0, high=1.0)

   Generate a pdarray with uniformly distributed random values in a specified range.

   :param low: The low value (inclusive) of the range
   :type low: int
   :param high: The high value (inclusive) of the range
   :type high: int
   :param size: The length of the returned array
   :type size: int

   :returns: Values drawn uniformly from the specified range
   :rtype: pdarray, float64

   .. rubric:: Examples

   >>> ak.uniform(3)
   array([0.92176432277231968, 0.083130710959903542, 0.68894208386667544])


.. function:: standard_normal(size)

   Draw real numbers from the standard normal distribution.

   :param size: The number of samples to draw (size of the returned array)
   :type size: int

   :returns: The array of random numbers
   :rtype: pdarray, float64

   .. seealso:: :func:`randint`

   .. rubric:: Notes

   For random samples from :math:`N(\mu, \sigma^2)`, use:

   ``(sigma * standard_normal(size)) + mu``


.. function:: random_strings_uniform(minlen, maxlen, size, characters='uppercase')

   Generate random strings with lengths uniformly distributed between
   minlen and maxlen, and with characters drawn from a specified set.

   :param minlen: The minimum allowed length of string
   :type minlen: int
   :param maxlen: The maximum allowed length of string
   :type maxlen: int
   :param size: The number of strings to generate
   :type size: int
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)

   :returns: The array of random strings
   :rtype: Strings

   .. seealso:: :func:`random_strings_lognormal`, :func:`randint`


.. function:: random_strings_lognormal(logmean, logstd, size, characters='uppercase')

   Generate random strings with log-normally distributed lengths and
   with characters drawn from a specified set.

   :param logmean: The log-mean of the length distribution
   :type logmean: float
   :param logstd: The log-standard-deviation of the length distribution
   :type logstd: float
   :param size: The number of strings to generate
   :type size: int
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)

   :returns: The array of random strings
   :rtype: Strings

   .. seealso:: :func:`random_strings_lognormal`, :func:`randint`

   .. rubric:: Notes

   The lengths of the generated strings are distributed $Lognormal(\mu, \sigma^2)$,
   with :math:`\mu = logmean` and :math:`\sigma = logstd`. Thus, the strings will have
   an average length of :math:`exp(\mu + 0.5*\sigma^2)`, a minimum length of zero, and
   a heavy tail towards longer strings.


.. function:: abs(pda)

   Return the element-wise absolute value of the array.


.. function:: log(pda)

   Return the element-wise natural log of the array.

   .. rubric:: Notes

   Logarithms with other bases can be computed as follows:

   >>> A = ak.array([1, 10, 100])
   # Natural log
   >>> ak.log(A)
   array([0, 2.3025850929940459, 4.6051701859880918])
   # Log base 10
   >>> ak.log(A) / np.log(10)
   array([0, 1, 2])
   # Log base 2
   >>> ak.log(A) / np.log(2)
   array([0, 3.3219280948873626, 6.6438561897747253])


.. function:: exp(pda)

   Return the element-wise exponential of the array.


.. function:: cumsum(pda)

   Return the cumulative sum over the array.

   The sum is inclusive, such that the ``i`` th element of the
   result is the sum of elements up to and including ``i``.


.. function:: cumprod(pda)

   Return the cumulative product over the array.

   The product is inclusive, such that the ``i`` th element of the
   result is the product of elements up to and including ``i``.


.. function:: sin(pda)

   Return the element-wise sine of the array.


.. function:: cos(pda)

   Return the element-wise cosine of the array.


.. function:: where(condition, A, B)

   Return an array with elements chosen from A and B based on a conditioning array.

   :param condition: Used to choose values from A or B
   :type condition: pdarray
   :param A: Value(s) used when condition is True
   :type A: scalar or pdarray
   :param B: Value(s) used when condition is False
   :type B: scalar or pdarray

   :returns: Values chosen from A and B according to condition
   :rtype: pdarray

   .. rubric:: Notes

   A and B must have the same dtype.


.. function:: histogram(pda, bins=10)

   Compute a histogram of evenly spaced bins over the range of an array.

   :param pda: The values to histogram
   :type pda: pdarray
   :param bins: The number of equal-size bins to use (default: 10)
   :type bins: int

   :returns: The number of values present in each bin
   :rtype: pdarray

   .. seealso:: :func:`value_counts`

   .. rubric:: Notes

   The bins are evenly spaced in the interval [pda.min(), pda.max()]. Currently,
   the user must re-compute the bin edges, e.g. with np.linspace (see below)
   in order to plot the histogram.

   .. rubric:: Examples

   >>> A = ak.arange(0, 10, 1)
   >>> nbins = 3
   >>> h = ak.histogram(A, bins=nbins)
   >>> h
   array([3, 3, 4])
   # Recreate the bin edges in NumPy
   >>> binEdges = np.linspace(A.min(), A.max(), nbins+1)
   >>> binEdges
   array([0., 3., 6., 9.])
   # To plot, use only the left edges, and export the histogram to NumPy
   >>> plt.plot(binEdges[:-1], h.to_ndarray())


.. function:: value_counts(pda)

   Count the occurrences of the unique values of an array.

   :param pda: The array of values to count
   :type pda: pdarray, int64

   :returns: * **unique_values** (*pdarray, int64*) -- The unique values, sorted in ascending order
             * **counts** (*pdarray, int64*) -- The number of times the corresponding unique value occurs

   .. seealso:: :func:`unique`, :func:`histogram`

   .. rubric:: Notes

   This function differs from ``histogram()`` in that it only returns counts
   for values that are present, leaving out empty "bins".

   .. rubric:: Examples

   >>> A = ak.array([2, 0, 2, 4, 0, 0])
   >>> ak.value_counts(A)
   (array([0, 2, 4]), array([3, 2, 1]))


.. function:: ls_hdf(filename)

   This function calls the h5ls utility on a filename visible to the arkouda
   server.

   :param filename: The name of the file to pass to h5ls
   :type filename: str

   :returns: The string output of `h5ls <filename>` from the server
   :rtype: str


.. function:: read_hdf(dsetName, filenames)

   Read a single dataset from multiple HDF5 files into an arkouda pdarray.

   :param dsetName: The name of the dataset (must be the same across all files)
   :type dsetName: str
   :param filenames: Either a list of filenames or shell expression
   :type filenames: list or str

   :returns: A pdarray instance pointing to the server-side data read in
   :rtype: pdarray

   .. seealso:: :func:`get_datasets`, :func:`ls_hdf`, :func:`read_all`, :func:`load`, :func:`save`

   .. rubric:: Notes

   If filenames is a string, it is interpreted as a shell expression
   (a single filename is a valid expression, so it will work) and is
   expanded with glob to read all matching files. Use ``get_datasets`` to
   show the names of datasets in HDF5 files.

   If dsetName is not present in all files, a RuntimeError is raised.


.. function:: read_all(filenames, datasets=None, iterative=False)

   Read datasets from HDF5 files.

   :param filenames: Either a list of filenames or shell expression
   :type filenames: list or str
   :param datasets: (List of) name(s) of dataset(s) to read (default: all available)
   :type datasets: list or str or None
   :param iterative: Iterative (True) or Single (False) function call(s) to server
   :type iterative: boolean

   :returns: * *For a single dataset returns an Arkouda pdarray or an Arkouda Sring and*
             * *for multiple datasets returns a dictionary of Ardkouda pdarrays and*
             * *Arkouda Strings.* -- Dictionary of {datasetName: pdarray or String}

   .. seealso:: :func:`read_hdf`, :func:`get_datasets`, :func:`ls_hdf`

   .. rubric:: Notes

   If filenames is a string, it is interpreted as a shell expression
   (a single filename is a valid expression, so it will work) and is
   expanded with glob to read all matching files.

   If iterative == True each dataset name and file names are passed to
   the server as independent sequential strings while if iterative == False
   all dataset names and file names are passed to the server in a single
   string.

   If datasets is None, infer the names of datasets from the first file
   and read all of them. Use ``get_datasets`` to show the names of datasets in
   HDF5 files.

   If not all datasets are present in all HDF5 files, a RuntimeError
   is raised.a


.. function:: load(path_prefix, dataset='array')

   Load a pdarray previously saved with ``pdarray.save()``.

   :param path_prefix: Filename prefix used to save the original pdarray
   :type path_prefix: str
   :param dataset: Dataset name where the pdarray was saved
   :type dataset: str

   :returns: The pdarray that was previously saved
   :rtype: pdarray

   .. seealso:: :func:`save`, :func:`load_all`, :func:`read_hdf`, :func:`read_all`


.. function:: get_datasets(filename)

   Get the names of datasets in an HDF5 file.

   :param filename: Name of an HDF5 file visible to the arkouda server
   :type filename: str

   :returns: Names of the datasets in the file
   :rtype: list of str

   .. seealso:: :func:`ls_hdf`


.. function:: load_all(path_prefix)

   Load multiple pdarray previously saved with ``save_all()``.

   :param path_prefix: Filename prefix used to save the original pdarray
   :type path_prefix: str

   :returns: Dictionary of {datsetName: pdarray} with the previously saved pdarrays
   :rtype: dict of pdarrays

   .. seealso:: :func:`save_all`, :func:`load`, :func:`read_hdf`, :func:`read_all`


.. function:: save_all(columns, path_prefix, names=None, mode='truncate')

   Save multiple named pdarrays to HDF5 files.

   :param columns: Collection of arrays to save
   :type columns: dict or list of pdarrays
   :param path_prefix: Directory and filename prefix for output files
   :type path_prefix: str
   :param names: Dataset names for the pdarrays
   :type names: list of str
   :param mode: By default, truncate (overwrite) the output files if they exist.
                If 'append', attempt to create new dataset in existing files.
   :type mode: {'truncate' | 'append'}

   .. seealso:: :func:`save`, :func:`load_all`

   .. rubric:: Notes

   Creates one file per locale containing that locale's chunk of each pdarray.
   If columns is a dictionary, the keys are used as the HDF5 dataset names.
   Otherwise, if no names are supplied, 0-up integers are used. By default,
   any existing files at path_prefix will be overwritten, unless the user
   specifies the 'append' mode, in which case arkouda will attempt to add
   <columns> as new datasets to existing files. If the wrong number of files
   is present or dataset names already exist, a RuntimeError is raised.


.. py:class:: GroupBy(keys, assume_sorted=False, hash_strings=True)

   Group an array or list of arrays by value, usually in preparation
   for aggregating the within-group values of another array.

   :param keys: The array to group by value, or if list, the column arrays to group by row
   :type keys: (list of) pdarray, int64 or Strings
   :param assume_sorted: If True, assume keys is already sorted (Default: False)
   :type assume_sorted: bool

   .. attribute:: nkeys

      The number of key arrays (columns)

      :type: int

   .. attribute:: size

      The length of the array(s), i.e. number of rows

      :type: int

   .. attribute:: permutation

      The permutation that sorts the keys array(s) by value (row)

      :type: pdarray

   .. attribute:: unique_keys

      The unique values of the keys array(s), in grouped order

      :type: (list of) pdarray or Strings

   .. attribute:: segments

      The start index of each group in the grouped array(s)

      :type: pdarray

   .. attribute:: unique_key_indices

      The first index in the raw (ungrouped) keys array(s) where each
      unique value (row) occurs

      :type: pdarray

   .. rubric:: Notes

   Only accepts pdarrays of int64 dtype or Strings.

   .. attribute:: Reductions
      

      

   .. method:: find_segments(self)



   .. method:: count(self)


      Count the number of elements in each group, i.e. the number of times
      each key appears.

      :param none:

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **counts** (*pdarray, int64*) -- The number of times each unique key appears


   .. method:: aggregate(self, values, operator)


      Using the permutation stored in the GroupBy instance, group another array
      of values and apply a reduction to each group's values.

      :param values: The values to group and reduce
      :type values: pdarray
      :param operator: The name of the reduction operator to use
      :type operator: str

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **aggregates** (*pdarray*) -- One aggregate value per unique key in the GroupBy instance


   .. method:: sum(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and sum each group's values.

      :param values: The values to group and sum
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_sums** (*pdarray*) -- One sum per unique key in the GroupBy instance

      .. rubric:: Notes

      The grouped sum of a boolean ``pdarray`` returns integers.


   .. method:: prod(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and compute the product of each group's values.

      :param values: The values to group and multiply
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_products** (*pdarray, float64*) -- One product per unique key in the GroupBy instance

      .. rubric:: Notes

      The return dtype is always float64.


   .. method:: mean(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and compute the mean of each group's values.

      :param values: The values to group and average
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_means** (*pdarray, float64*) -- One mean value per unique key in the GroupBy instance

      .. rubric:: Notes

      The return dtype is always float64.


   .. method:: min(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and return the minimum of each group's values.

      :param values: The values to group and find minima
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_minima** (*pdarray*) -- One minimum per unique key in the GroupBy instance


   .. method:: max(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and return the maximum of each group's values.

      :param values: The values to group and find maxima
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_maxima** (*pdarray*) -- One maximum per unique key in the GroupBy instance


   .. method:: argmin(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and return the location of the first minimum of each group's values.

      :param values: The values to group and find argmin
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_argminima** (*pdarray, int64*) -- One index per unique key in the GroupBy instance

      .. rubric:: Notes

      The returned indices refer to the original values array as passed in, not
      the permutation applied by the GroupBy instance.

      .. rubric:: Examples

      >>> A = ak.array([0, 1, 0, 1, 0, 1])
      >>> B = ak.array([0, 1, 1, 0, 0, 1])
      >>> byA = ak.GroupBy(A)
      >>> byA.argmin(B)
      (array([0, 1]), array([0, 3]))


   .. method:: argmax(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and return the location of the first maximum of each group's values.

      :param values: The values to group and find argmax
      :type values: pdarray

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_argmaxima** (*pdarray, int64*) -- One index per unique key in the GroupBy instance

      .. rubric:: Notes

      The returned indices refer to the original values array as passed in, not
      the permutation applied by the GroupBy instance.

      .. rubric:: Examples

      >>> A = ak.array([0, 1, 0, 1, 0, 1])
      >>> B = ak.array([0, 1, 1, 0, 0, 1])
      >>> byA = ak.GroupBy(A)
      >>> byA.argmax(B)
      (array([0, 1]), array([2, 1]))


   .. method:: nunique(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and return the number of unique values in each group.

      :param values: The values to group and find unique values
      :type values: pdarray, int64

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_nunique** (*pdarray, int64*) -- Number of unique values per unique key in the GroupBy instance


   .. method:: any(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and perform an "or" reduction on each group.

      :param values: The values to group and reduce with "or"
      :type values: pdarray, bool

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_any** (*pdarray, bool*) -- One bool per unique key in the GroupBy instance


   .. method:: all(self, values)


      Using the permutation stored in the GroupBy instance, group another array
      of values and perform an "and" reduction on each group.

      :param values: The values to group and reduce with "and"
      :type values: pdarray, bool

      :returns: * **unique_keys** (*(list of) pdarray or Strings*) -- The unique keys, in grouped order
                * **group_any** (*pdarray, bool*) -- One bool per unique key in the GroupBy instance


   .. method:: broadcast(self, values)


      Fill each group's segment with a constant value.

      :param values: The values to put in each group's segment
      :type values: pdarray

      :returns: The broadcast values
      :rtype: pdarray

      .. rubric:: Notes

      This function is a sparse analog of ``np.broadcast``. If a
      GroupBy object represents a sparse matrix (tensor), then
      this function takes a (dense) column vector and replicates
      each value to the non-zero elements in the corresponding row.

      The returned array is in permuted (grouped) order. To get
      back to the order of the array on which GroupBy was called,
      the user must invert the permutation (see below).

      .. rubric:: Examples

      >>> a = ak.array([0, 1, 0, 1, 0])
      >>> values = ak.array([3, 5])
      >>> g = ak.GroupBy(a)
      # Result is in grouped order
      >>> g.broadcast(values)
      array([3, 3, 3, 5, 5]

      >>> b = ak.zeros_like(a)
      # Result is in original order
      >>> b[g.permutation] = g.broadcast(values)
      >>> b
      array([3, 5, 3, 5, 3])



.. py:class:: Strings(offset_attrib, bytes_attrib)

   Represents an array of strings whose data resides on the
   arkouda server. The user should not call this class directly;
   rather its instances are created by other arkouda functions.

   .. attribute:: offsets

      The starting indices for each string

      :type: pdarray

   .. attribute:: bytes

      The raw bytes of all strings, joined by nulls

      :type: pdarray

   .. attribute:: size

      The number of strings in the array

      :type: int

   .. attribute:: nbytes

      The total number of bytes in all strings

      :type: int

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: int

   .. attribute:: shape

      The sizes of each dimension of the array

      :type: tuple

   .. attribute:: BinOps
      

      

   .. attribute:: objtype
      :annotation: = str

      

   .. method:: __iter__(self)



   .. method:: __len__(self)



   .. method:: __str__(self)


      Return str(self).


   .. method:: __repr__(self)


      Return repr(self).


   .. method:: binop(self, other, op)



   .. method:: __eq__(self, other)


      Return self==value.


   .. method:: __ne__(self, other)


      Return self!=value.


   .. method:: __getitem__(self, key)



   .. method:: get_lengths(self)


      Return the length of each string in the array.

      :returns: The length of each string
      :rtype: pdarray, int


   .. method:: contains(self, substr)


      Check whether each element contains the given substring.

      :param substr: The substring to search for
      :type substr: str

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray, bool

      .. seealso:: :meth:`Strings.startswith`, :meth:`Strings.endswith`


   .. method:: startswith(self, substr)


      Check whether each element starts with the given substring.

      :param substr: The prefix to search for
      :type substr: str

      :returns: True for elements that start with substr, False otherwise
      :rtype: pdarray, bool

      .. seealso:: :meth:`Strings.contains`, :meth:`Strings.endswith`


   .. method:: endswith(self, substr)


      Check whether each element ends with the given substring.

      :param substr: The suffix to search for
      :type substr: str

      :returns: True for elements that end with substr, False otherwise
      :rtype: pdarray, bool

      .. seealso:: :meth:`Strings.contains`, :meth:`Strings.startswith`


   .. method:: peel(self, delimiter, times=1, includeDelimiter=False, keepPartial=False, fromRight=False)


      Peel off one or more delimited fields from each string (similar
      to string.partition), returning two new arrays of strings.

      :param delimiter: The separator where the split will occur
      :type delimiter: str
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the first (times-1) delimiters
      :type times: int
      :param includeDelimiter: If true, append the delimiter to the end of the first return
                               array. By default, it is prepended to the beginning of the
                               second return array.
      :type includeDelimiter: bool
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the first array. By default,
                          such strings are returned in the second array.
      :type keepPartial: bool
      :param fromRight: If true, peel from the right instead of the left (see also rpeel)
      :type fromRight: bool

      :returns: * **left** (*Strings*) -- The field(s) peeled from the end of each string (unless
                  fromRight is true)
                * **right** (*Strings*) -- The remainder of each string after peeling (unless fromRight
                  is true)

      .. seealso:: :meth:`rpeel`, :meth:`stick`, :meth:`lstick`

      .. rubric:: Examples

      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', includeDelimiter=True)
      (array(['a.', 'c.', 'e.']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', times=2)
      (array(['', '', 'e.f']), array(['a.b', 'c.d', 'g']))
      >>> s.peel('.', times=2, keepPartial=True)
      (array(['a.b', 'c.d', 'e.f']), array(['', '', 'g']))


   .. method:: rpeel(self, delimiter, times=1, includeDelimiter=False, keepPartial=False)


      Peel off one or more delimited fields from the end of each string
      (similar to string.rpartition), returning two new arrays of strings.

      :param delimiter: The separator where the split will occur
      :type delimiter: str
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the last (times-1) delimiters
      :type times: int
      :param includeDelimiter: If true, prepend the delimiter to the start of the first return
                               array. By default, it is appended to the end of the
                               second return array.
      :type includeDelimiter: bool
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the second array. By default,
                          such strings are returned in the first array.
      :type keepPartial: bool

      :returns: * **left** (*Strings*) -- The remainder of the string after peeling
                * **right** (*Strings*) -- The field(s) that were peeled from the right of each string

      .. seealso:: :meth:`peel`, :meth:`stick`, :meth:`lstick`

      .. rubric:: Examples

      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.rpeel('.')
      (array(['a', 'c', 'e.f']), array(['b', 'd', 'g']))
      # Compared against peel
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))


   .. method:: stick(self, other, delimiter='', toLeft=False)


      Join the strings from another array onto one end of the strings
      of this array, optionally inserting a delimiter.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: str
      :param toLeft: If true, join other strings to the left of self. By default,
                     other is joined to the right of self.
      :type toLeft: bool

      :returns: The array of joined strings
      :rtype: Strings

      .. seealso:: :meth:`lstick`, :meth:`peel`, :meth:`rpeel`

      .. rubric:: Examples

      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.stick(t, delimiter='.')
      array(['a.b', 'c.d', 'e.f'])


   .. method:: __add__(self, other)



   .. method:: lstick(self, other, delimiter='')


      Join the strings from another array onto the left of the strings
      of this array, optionally inserting a delimiter.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: str

      :returns: The array of joined strings, as other + self
      :rtype: Strings

      .. seealso:: :meth:`stick`, :meth:`peel`, :meth:`rpeel`

      .. rubric:: Examples

      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.lstick(t, delimiter='.')
      array(['b.a', 'd.c', 'f.e'])


   .. method:: __radd__(self, other)



   .. method:: hash(self)


      Compute a 128-bit hash of each string.

      :returns: A pair of int64 pdarrays. The ith hash value is the concatenation
                of the ith values from each array.
      :rtype: (pdarray, pdarray)

      .. rubric:: Notes

      The implementation uses SipHash128, a fast and balanced hash function (used
      by Python for dictionaries and sets). For realistic numbers of strings (up
      to about 10**15), the probability of a collision between two 128-bit hash
      values is negligible.


   .. method:: group(self)


      Return the permutation that groups the array, placing equivalent
      strings together. All instances of the same string are guaranteed to lie
      in one contiguous block of the permuted array, but the blocks are not
      necessarily ordered.

      :returns: The permutation that groups the array by value
      :rtype: pdarray

      .. seealso:: :meth:`GroupBy`, :meth:`unique`

      .. rubric:: Notes

      If the arkouda server is compiled with "-sSegmentedArray.useHash=true",
      then arkouda uses 128-bit hash values to group strings, rather than sorting
      the strings directly. This method is fast, but the resulting permutation
      merely groups equivalent strings and does not sort them. If the "useHash"
      parameter is false, then a full sort is performed.


   .. method:: to_ndarray(self)


      Convert the array to a np.ndarray, transferring array data from the
      arkouda server to Python. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A numpy ndarray with the same strings as this array
      :rtype: np.ndarray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``arkouda.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :meth:`array`

      .. rubric:: Examples

      >>> a = ak.array(["hello", "my", "world"])
      >>> a.to_ndarray()
      array(['hello', 'my', 'world'], dtype='<U5')

      >>> type(a.to_ndarray())
      numpy.ndarray



.. function:: join_on_eq_with_dt(a1, a2, t1, t2, dt, pred, result_limit=1000)


.. function:: register_pda(pda, user_defined_name)


.. function:: attach_pda(name)


.. function:: unregister_pda(pda)


.. py:class:: Categorical(values, **kwargs)

   Represents an array of values belonging to named categories. Converting a Strings
   object to Categorical often saves memory and speeds up operations, especially
   if there are many repeated values, at the cost of some one-time work in initialization.

   :param values: String values to convert to categories
   :type values: Strings

   .. attribute:: categories

      The set of category labels (determined automatically)

      :type: Strings

   .. attribute:: codes

      The category indices of the values or -1 for N/A

      :type: pdarray, int64

   .. attribute:: permutation

      The permutation that groups the values in the same order as categories

      :type: pdarray, int64

   .. attribute:: segments

      When values are grouped, the starting offset of each group

      :type: pdarray, int64

   .. attribute:: size

      The number of items in the array

      :type: int

   .. attribute:: nlevels

      The number of distinct categories

      :type: int

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: int

   .. attribute:: shape

      The sizes of each dimension of the array

      :type: tuple

   .. attribute:: BinOps
      

      

   .. attribute:: objtype
      :annotation: = category

      

   .. attribute:: permutation
      

      

   .. attribute:: segments
      

      

   .. method:: from_codes(cls, codes, categories, permutation=None, segments=None)
      :classmethod:


      Make a Categorical from codes and categories arrays. If codes and categories
      have already been precomputed, this constructor saves time. If not, please
      use the normal constructor.

      :param codes: Category indices of each value
      :type codes: pdarray, int64
      :param categories: Unique category labels
      :type categories: String


   .. method:: to_ndarray(self)


      Convert the array to a np.ndarray, transferring array data from the
      arkouda server to Python. This conversion discards category information
      and produces an ndarray of strings. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A numpy ndarray of strings corresponding to the values in this array
      :rtype: np.ndarray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``arkouda.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.maxTransferBytes to a larger
      value, but proceed with caution.


   .. method:: __iter__(self)



   .. method:: __len__(self)



   .. method:: __str__(self)


      Return str(self).


   .. method:: __repr__(self)


      Return repr(self).


   .. method:: binop(self, other, op)



   .. method:: r_binop(self, other, op)



   .. method:: __eq__(self, other)


      Return self==value.


   .. method:: __neq__(self, other)



   .. method:: __getitem__(self, key)



   .. method:: reset_categories(self)


      Recompute the category labels, discarding any unused labels. This method
      is often useful after slicing or indexing a Categorical array, when the
      resulting array only contains a subset of the original categories. In
      this case, eliminating unused categories can speed up other operations.


   .. method:: contains(self, substr)


      Check whether each element contains the given substring.

      :param substr: The substring to search for
      :type substr: str

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray, bool

      .. rubric:: Notes

      This method can be significantly faster than the corresponding method
      on Strings objects, because it searches the unique category labels
      instead of the full array.

      .. seealso:: :meth:`Categorical.startswith`, :meth:`Categorical.endswith`


   .. method:: startswith(self, substr)


      Check whether each element starts with the given substring.

      :param substr: The substring to search for
      :type substr: str

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray, bool

      .. rubric:: Notes

      This method can be significantly faster than the corresponding method
      on Strings objects, because it searches the unique category labels
      instead of the full array.

      .. seealso:: :meth:`Categorical.contains`, :meth:`Categorical.endswith`


   .. method:: endswith(self, substr)


      Check whether each element ends with the given substring.

      :param substr: The substring to search for
      :type substr: str

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray, bool

      .. rubric:: Notes

      This method can be significantly faster than the corresponding method
      on Strings objects, because it searches the unique category labels
      instead of the full array.

      .. seealso:: :meth:`Categorical.startswith`, :meth:`Categorical.contains`


   .. method:: in1d(self, test)



   .. method:: unique(self)



   .. method:: group(self)


      Return the permutation that groups the array, placing equivalent
      categories together. All instances of the same category are guaranteed to lie
      in one contiguous block of the permuted array, but the blocks are not
      necessarily ordered.

      :returns: The permutation that groups the array by value
      :rtype: pdarray

      .. seealso:: :meth:`GroupBy`, :meth:`unique`

      .. rubric:: Notes

      This method is faster than the corresponding Strings method. If the Categorical
      was created from a Strings object, then this function simply returns the
      cached permutation. Even if the Categorical was created using from_codes(),
      this function will be faster than Strings.group() because it sorts dense
      integer values, rather than 128-bit hash values.


   .. method:: argsort(self)



   .. method:: sort(self)



   .. method:: merge(self, others)


      Merge this Categorical with other Categoricals, concatenating the arrays and
      synchronizing the categories.

      :param others: The Categorical arrays to concatenate and merge with this one
      :type others: list of Categorical

      .. rubric:: Notes

      This operation can be expensive -- slower than concatenating Strings arrays.



