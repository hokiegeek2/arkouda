:mod:`arkouda.strings`
======================

.. py:module:: arkouda.strings


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   arkouda.strings.Strings



.. py:class:: Strings(offset_attrib, bytes_attrib)

   Represents an array of strings whose data resides on the
   arkouda server. The user should not call this class directly;
   rather its instances are created by other arkouda functions.

   .. attribute:: offsets

      The starting indices for each string

      :type: pdarray

   .. attribute:: bytes

      The raw bytes of all strings, joined by nulls

      :type: pdarray

   .. attribute:: size

      The number of strings in the array

      :type: int

   .. attribute:: nbytes

      The total number of bytes in all strings

      :type: int

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: int

   .. attribute:: shape

      The sizes of each dimension of the array

      :type: tuple

   .. attribute:: BinOps
      

      

   .. attribute:: objtype
      :annotation: = str

      

   .. method:: __iter__(self)



   .. method:: __len__(self)



   .. method:: __str__(self)


      Return str(self).


   .. method:: __repr__(self)


      Return repr(self).


   .. method:: binop(self, other, op)



   .. method:: __eq__(self, other)


      Return self==value.


   .. method:: __ne__(self, other)


      Return self!=value.


   .. method:: __getitem__(self, key)



   .. method:: get_lengths(self)


      Return the length of each string in the array.

      :returns: The length of each string
      :rtype: pdarray, int


   .. method:: contains(self, substr)


      Check whether each element contains the given substring.

      :param substr: The substring to search for
      :type substr: str

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray, bool

      .. seealso:: :meth:`Strings.startswith`, :meth:`Strings.endswith`


   .. method:: startswith(self, substr)


      Check whether each element starts with the given substring.

      :param substr: The prefix to search for
      :type substr: str

      :returns: True for elements that start with substr, False otherwise
      :rtype: pdarray, bool

      .. seealso:: :meth:`Strings.contains`, :meth:`Strings.endswith`


   .. method:: endswith(self, substr)


      Check whether each element ends with the given substring.

      :param substr: The suffix to search for
      :type substr: str

      :returns: True for elements that end with substr, False otherwise
      :rtype: pdarray, bool

      .. seealso:: :meth:`Strings.contains`, :meth:`Strings.startswith`


   .. method:: peel(self, delimiter, times=1, includeDelimiter=False, keepPartial=False, fromRight=False)


      Peel off one or more delimited fields from each string (similar
      to string.partition), returning two new arrays of strings.

      :param delimiter: The separator where the split will occur
      :type delimiter: str
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the first (times-1) delimiters
      :type times: int
      :param includeDelimiter: If true, append the delimiter to the end of the first return
                               array. By default, it is prepended to the beginning of the
                               second return array.
      :type includeDelimiter: bool
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the first array. By default,
                          such strings are returned in the second array.
      :type keepPartial: bool
      :param fromRight: If true, peel from the right instead of the left (see also rpeel)
      :type fromRight: bool

      :returns: * **left** (*Strings*) -- The field(s) peeled from the end of each string (unless
                  fromRight is true)
                * **right** (*Strings*) -- The remainder of each string after peeling (unless fromRight
                  is true)

      .. seealso:: :meth:`rpeel`, :meth:`stick`, :meth:`lstick`

      .. rubric:: Examples

      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', includeDelimiter=True)
      (array(['a.', 'c.', 'e.']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', times=2)
      (array(['', '', 'e.f']), array(['a.b', 'c.d', 'g']))
      >>> s.peel('.', times=2, keepPartial=True)
      (array(['a.b', 'c.d', 'e.f']), array(['', '', 'g']))


   .. method:: rpeel(self, delimiter, times=1, includeDelimiter=False, keepPartial=False)


      Peel off one or more delimited fields from the end of each string
      (similar to string.rpartition), returning two new arrays of strings.

      :param delimiter: The separator where the split will occur
      :type delimiter: str
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the last (times-1) delimiters
      :type times: int
      :param includeDelimiter: If true, prepend the delimiter to the start of the first return
                               array. By default, it is appended to the end of the
                               second return array.
      :type includeDelimiter: bool
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the second array. By default,
                          such strings are returned in the first array.
      :type keepPartial: bool

      :returns: * **left** (*Strings*) -- The remainder of the string after peeling
                * **right** (*Strings*) -- The field(s) that were peeled from the right of each string

      .. seealso:: :meth:`peel`, :meth:`stick`, :meth:`lstick`

      .. rubric:: Examples

      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.rpeel('.')
      (array(['a', 'c', 'e.f']), array(['b', 'd', 'g']))
      # Compared against peel
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))


   .. method:: stick(self, other, delimiter='', toLeft=False)


      Join the strings from another array onto one end of the strings
      of this array, optionally inserting a delimiter.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: str
      :param toLeft: If true, join other strings to the left of self. By default,
                     other is joined to the right of self.
      :type toLeft: bool

      :returns: The array of joined strings
      :rtype: Strings

      .. seealso:: :meth:`lstick`, :meth:`peel`, :meth:`rpeel`

      .. rubric:: Examples

      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.stick(t, delimiter='.')
      array(['a.b', 'c.d', 'e.f'])


   .. method:: __add__(self, other)



   .. method:: lstick(self, other, delimiter='')


      Join the strings from another array onto the left of the strings
      of this array, optionally inserting a delimiter.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: str

      :returns: The array of joined strings, as other + self
      :rtype: Strings

      .. seealso:: :meth:`stick`, :meth:`peel`, :meth:`rpeel`

      .. rubric:: Examples

      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.lstick(t, delimiter='.')
      array(['b.a', 'd.c', 'f.e'])


   .. method:: __radd__(self, other)



   .. method:: hash(self)


      Compute a 128-bit hash of each string.

      :returns: A pair of int64 pdarrays. The ith hash value is the concatenation
                of the ith values from each array.
      :rtype: (pdarray, pdarray)

      .. rubric:: Notes

      The implementation uses SipHash128, a fast and balanced hash function (used
      by Python for dictionaries and sets). For realistic numbers of strings (up
      to about 10**15), the probability of a collision between two 128-bit hash
      values is negligible.


   .. method:: group(self)


      Return the permutation that groups the array, placing equivalent
      strings together. All instances of the same string are guaranteed to lie
      in one contiguous block of the permuted array, but the blocks are not
      necessarily ordered.

      :returns: The permutation that groups the array by value
      :rtype: pdarray

      .. seealso:: :meth:`GroupBy`, :meth:`unique`

      .. rubric:: Notes

      If the arkouda server is compiled with "-sSegmentedArray.useHash=true",
      then arkouda uses 128-bit hash values to group strings, rather than sorting
      the strings directly. This method is fast, but the resulting permutation
      merely groups equivalent strings and does not sort them. If the "useHash"
      parameter is false, then a full sort is performed.


   .. method:: to_ndarray(self)


      Convert the array to a np.ndarray, transferring array data from the
      arkouda server to Python. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A numpy ndarray with the same strings as this array
      :rtype: np.ndarray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``arkouda.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :meth:`array`

      .. rubric:: Examples

      >>> a = ak.array(["hello", "my", "world"])
      >>> a.to_ndarray()
      array(['hello', 'my', 'world'], dtype='<U5')

      >>> type(a.to_ndarray())
      numpy.ndarray



