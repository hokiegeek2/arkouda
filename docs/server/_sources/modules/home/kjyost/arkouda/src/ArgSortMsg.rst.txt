.. default-domain:: chpl

.. module:: ArgSortMsg
   :synopsis: arg sort algorithm

ArgSortMsg
==========
**Usage**

.. code-block:: chapel

   use ArgSortMsg;


or

.. code-block:: chapel

   import ArgSortMsg;

arg sort algorithm
these pass back an index vector which can be used
to permute the original array into sorted order 

.. data:: var lgSmall = 10

.. data:: var small = 2**lgSmall

.. data:: var lgMedium = 20

.. data:: var medium = 2**lgMedium

.. data:: var lgLarge = 30

.. data:: var large = 2**lgLarge

.. data:: var sBins = 2**10

.. data:: var mBins = 2**25

.. data:: var lBins = 2**25*numLocales

.. function:: proc incrementalArgSort(g: GenSymEntry, iv: [?aD] int): [] int throws

   Perform one step in a multi-step argsort, starting with an initial 
   permutation vector and further permuting it in the manner required
   to sort an array of keys.
   

.. function:: proc incrementalArgSort(s: SegString, iv: [?aD] int): [] int throws

.. function:: proc coargsortMsg(reqMsg: string, st: borrowed SymTab) throws

   Find the permutation that sorts multiple arrays, treating each array as a
   new level of the sorting key.
   

.. function:: proc argsortDefault(A: [?D] ?t): [D] int

.. function:: proc argsortMsg(reqMsg: string, st: borrowed SymTab): string throws

   argsort takes pdarray and returns an index vector iv which sorts the array 

.. function:: proc localArgsortMsg(reqMsg: string, st: borrowed SymTab): string throws

   localArgsort takes a pdarray and returns an index vector which sorts the array on a per-locale basis 

.. function:: proc perLocaleArgSort(a: [?aD] int): [aD] int

.. function:: proc perLocaleArgCountSort(a: [?aD] int): [aD] int

.. function:: proc localAssocArgSort(iv: [] int, a: [?D] int)

