.. default-domain:: chpl

.. module:: ReductionMsg

ReductionMsg
============
**Usage**

.. code-block:: chapel

   use ReductionMsg;


or

.. code-block:: chapel

   import ReductionMsg;

.. function:: proc reductionMsg(cmd: string, payload: bytes, st: borrowed SymTab): string throws

.. function:: proc countReductionMsg(cmd: string, payload: bytes, st: borrowed SymTab): string throws

.. function:: proc segCount(segments: [?D] int, upper: int): [D] int

.. function:: proc countLocalRdxMsg(cmd: string, payload: bytes, st: borrowed SymTab): string throws

.. function:: proc perLocCount(segments: [?D] int, size: int): [] int

.. function:: proc segmentedReductionMsg(cmd: string, payload: bytes, st: borrowed SymTab): string throws

.. function:: proc segmentedLocalRdxMsg(cmd: string, payload: bytes, st: borrowed SymTab): string throws

.. function:: proc segSum(values: [] ?t, segments: [?D] int): [D] t

   Segmented Reductions of the form: seg<Op>(values:[] t, segments: [] int)
   Use <segments> as the boundary indices to divide <values> into chunks, 
   and then reduce over each chunk uisng the operator <Op>. The return array 
   of reduced values is the same size as <segments>.
   

.. function:: proc perLocSum(values: [] ?t, segments: [?D] int): [] t

   Per-Locale Segmented Reductions have the same form as segmented reductions:
   perLoc<Op>(values:[] t, segments: [] int)
   However, in this case <segments> has length <numSegments>*<numLocales> and
   stores the segment boundaries for each locale's chunk of <values>. These
   reductions perform two stages: a local reduction (implemented via a call
   to seg<Op> on the local slice of values) and a global reduction of the 
   local results. The return is the same as seg<Op>: one reduced value per segment.
   

.. function:: proc segSum(values: [] bool, segments: [?D] int): [D] int

.. function:: proc perLocSum(values: [] bool, segments: [?D] int): [] int

.. function:: proc segProduct(values: [], segments: [?D] int): [D] real

.. function:: proc perLocProduct(values: [] ?t, segments: [?D] int): [] real

.. function:: proc segMean(values: [] ?t, segments: [?D] int): [D] real

.. function:: proc perLocMean(values: [] ?t, segments: [?D] int): [] real

.. function:: proc segMin(values: [?vD] ?t, segments: [?D] int): [D] t

.. function:: proc perLocMin(values: [] ?t, segments: [?D] int): [] t

.. function:: proc segMax(values: [?vD] ?t, segments: [?D] int): [D] t

.. function:: proc perLocMax(values: [] ?t, segments: [?D] int): [] t

.. function:: proc segArgmin(values: [?vD] ?t, segments: [?D] int): (AppendExpr.01, AppendExpr.01)

.. function:: proc perLocArgmin(values: [] ?t, segments: [?D] int): [] int

.. function:: proc segArgmax(values: [?vD] ?t, segments: [?D] int): (AppendExpr.01, AppendExpr.01)

.. function:: proc perLocArgmax(values: [] ?t, segments: [?D] int): [] int

.. function:: proc segAny(values: [] bool, segments: [?D] int): [D] bool

.. function:: proc perLocAny(values: [] bool, segments: [?D] int): [] bool

.. function:: proc segAll(values: [] bool, segments: [?D] int): [D] bool

.. function:: proc perLocAll(values: [] bool, segments: [?D] int): [] bool

.. function:: proc expandKeys(kD, segments: [?sD] int): [kD] int

   } 

.. function:: proc segNumUnique(values: [?kD] int, segments: [?sD] int)

.. function:: proc perLocNumUnique(values: [] int, segments: [?D] int): [] int

   } 

.. function:: proc perLocNumUniqueHist(values: [] int, segments: [?D] int, minVal: int, valRange: int, numKeys: int): [] int

   } 

.. function:: proc perLocNumUniqueAssoc(values: [] int, segments: [?D] int, numKeys: int): [] int

